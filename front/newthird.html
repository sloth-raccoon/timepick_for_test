<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timetable Planner - TIMEPICK</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- REMOVED Google Font Import -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #f8f9fa;
            min-height: 100vh;
        }
        .layout {
            display: flex;
            height: 100vh;
            box-sizing: border-box;
        }
        .main {
            flex: 1;
            padding: 20px;
            margin-left: 0;
            overflow-y: auto; /* Add scroll for main content if tables get too wide/long */
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #ffffff;
            color: #343a40;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        .button {
            background-color: #67AD5B;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin: 5px;
        }
        .button:hover {
            background-color: #558C4A;
        }
        .container {
            display: flex;
            gap: 20px;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap; /* Allow boxes to wrap */
        }
        .box {
            flex: 1;
            min-width: 350px; /* Adjust min-width as needed */
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            background-color: #ffffff;
            overflow-x: auto; /* Allow horizontal scroll within each box if table is wide */
        }
        table {
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            text-align: center;
            padding: 8px 5px;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            height: 30px;
            min-width: 50px; /* Adjust min-width for date columns */
            white-space: nowrap; /* Prevent header text wrapping */
        }
        th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: bold;
            position: sticky; /* Make header sticky */
            top: 0; /* Stick to the top of the scrolling container (.box) */
            z-index: 1; /* Ensure header is above table content */
        }
        td {
            background-color: #ffffff;
            transition: background-color 0.2s ease;
        }
        /* --- REMOVED General td:hover rule --- */
        /* td:hover {
             background-color: #e9ecef;
        } */

        /* --- ADDED Specific hover rule for 'none' state cells --- */
        #your-table td.your-time-none:hover,
        #group-table td.group-color-0:hover {
             background-color: #e9ecef; /* Consistent hover effect */
        }
        /* --- END ADDED --- */

        /* Style for time column cells (first column) */
        #your-table th:first-child,
        #your-table td:first-child,
        #group-table th:first-child,
        #group-table td:first-child {
            background-color: #f8f9fa;
            font-weight: bold;
            color: #343a40;
            cursor: default;
            position: sticky; /* Make time column sticky */
            left: 0; /* Stick to the left */
            z-index: 2; /* Ensure time column is above header and content */
            min-width: 60px; /* Ensure time label width */
        }
         /* Ensure the top-left cell is styled correctly and above others */
        #your-table th:first-child,
        #group-table th:first-child {
            z-index: 3;
        }

        .legend {
            display: flex;
            align-items: center;
            gap: 5px 15px;
            margin-top: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #343a40;
        }
        .color-box {
            width: 15px;
            height: 15px;
            display: inline-block;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 3px;
        }
        h3 {
            font-size: 20px;
            color: #343a40;
            font-weight: bold;
            margin-top: 0;
            margin-bottom: 15px;
        }
        .language-switcher select {
             padding: 5px 10px;
             border-radius: 8px;
             border: 1px solid #cbd5e1;
             background-color: #ffffff;
             font-size: 14px;
        }
        /* Group Availability Colors */
        .group-color-0 { background-color: #ffffff; border: 1px solid #eee; }
        .group-color-1 { background-color: #e0f7fa; }
        .group-color-2 { background-color: #b2ebf2; }
        .group-color-3 { background-color: #80deea; }
        .group-color-4 { background-color: #4dd0e1; }
        .group-color-5 { background-color: #26c6da; }

        /* Your Time Colors */
        .your-time-none { background-color: #ffffff; border: 1px solid #eee; }
        .your-time-available { background-color: #a7f3d0; }

        #group-status {
            font-weight: bold;
            color: #343a40;
            margin-top: 10px;
            display: block;
        }

    </style>
</head>
<body>
    <div class="layout">
        <div class="main" id="main">
            <div class="header">
                <div>
                    <button class="button" onclick="location.reload()">New</button>
                    <button class="button" onclick="saveSchedule()">Save</button>
                    <button class="button" onclick="resetAll()">Reset Tables</button>
                </div>
                <div class="language-switcher">
                    <select id="language-select">
                        <option value="en">English</option>
                        <option value="zh">繁體中文</option>
                    </select>
                </div>
            </div>
            <div class="container">
                <div class="box">
                    <h3>My Time</h3>
                    <div class="legend">
                        <div class="color-box your-time-none" style="border: 1px solid #ccc;"></div> None
                        <div class="color-box your-time-available"></div> Available
                    </div>
                    <table id="your-table">
                        <thead>
                             <!-- Header row will be populated by JS -->
                             <tr><th>Time</th></tr>
                        </thead>
                        <tbody><!-- Populated by JS --></tbody>
                    </table>
                </div>
                <div class="box">
                    <h3>Group Availability</h3>
                    <div class="legend">
                        <div class="color-box group-color-1"></div> 1/5
                        <div class="color-box group-color-2"></div> 2/5
                        <div class="color-box group-color-3"></div> 3/5
                        <div class="color-box group-color-4"></div> 4/5
                        <div class="color-box group-color-5"></div> 5/5
                    </div>
                    <span id="group-status">0/0 Fully Available</span>
                    <table id="group-table">
                        <thead>
                             <!-- Header row will be populated by JS -->
                             <tr><th>Time</th></tr>
                        </thead>
                        <tbody><!-- Populated by JS --></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT REMAINS UNCHANGED ---
        let isDragging = false;
        let currentDragState = null;
        const groupMax = 5;

        // --- DOM Elements ---
        const yourTable = document.getElementById('your-table');
        const groupTable = document.getElementById('group-table');
        const yourTableHeadRow = yourTable.querySelector('thead tr');
        const groupTableHeadRow = groupTable.querySelector('thead tr');
        const yourTableBody = yourTable.querySelector('tbody');
        const groupTableBody = groupTable.querySelector('tbody');
        const groupStatusSpan = document.getElementById('group-status');

        // --- Constants for Styles ---
        const YOUR_TIME_CLASSES = {
            none: 'your-time-none',
            available: 'your-time-available'
        };
        const GROUP_COLOR_CLASSES = [
            'group-color-0', 'group-color-1', 'group-color-2',
            'group-color-3', 'group-color-4', 'group-color-5'
        ];

        // --- Functions ---

        function createRows(start, end) {
            const times = [];
            if (start >= end) {
                console.warn("Start time must be before end time.");
                return times;
            }
            for (let i = start; i < end; i++) {
                times.push(i.toString().padStart(2, '0') + ':00');
            }
            return times;
        }

        function populateTables() {
            // Clear existing table content
            yourTableHeadRow.innerHTML = '<th>Time</th>'; // Keep the first header cell
            groupTableHeadRow.innerHTML = '<th>Time</th>';
            yourTableBody.innerHTML = '';
            groupTableBody.innerHTML = '';

            // --- Retrieve data from localStorage ---
            let start = 9; // Default start
            let end = 18; // Default end
            let selectedDates = []; // Default empty array
            const savedData = localStorage.getItem('schedule_data');

            if (savedData) {
                try {
                    const scheduleData = JSON.parse(savedData);
                    start = parseInt(scheduleData.startTime?.split(':')[0] ?? start);
                    end = parseInt(scheduleData.endTime?.split(':')[0] ?? end);
                    selectedDates = scheduleData.selectedDates || [];

                    if (isNaN(start) || isNaN(end) || start >= end) {
                         console.warn("Invalid start/end time from localStorage, using defaults.");
                         start = 9;
                         end = 18;
                    }
                    if (!Array.isArray(selectedDates)) {
                        console.warn("Invalid selectedDates from localStorage, using empty array.");
                        selectedDates = [];
                    }

                } catch (e) {
                    console.error("Error parsing schedule data from localStorage:", e);
                    selectedDates = []; // Reset on error
                }
            } else {
                 console.log("No schedule data found in localStorage, using default times (9-18) and no dates.");
            }

            // --- Process and Sort Dates ---
            const sortedDates = selectedDates
                .map(dateStr => new Date(dateStr + 'T00:00:00')) // Ensure parsing as local date
                .filter(date => !isNaN(date.getTime())) // Filter out invalid dates
                .sort((a, b) => a - b);

            // --- Generate Table Headers (Dates) ---
            const dateHeaders = []; // Store header info for body generation
            sortedDates.forEach(date => {
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const formattedDate = `${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}`; // MM/DD
                const dateString = `${date.getFullYear()}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`; // YYYY-MM-DD

                dateHeaders.push({ formatted: formattedDate, full: dateString });

                const thYour = document.createElement('th');
                thYour.textContent = formattedDate;
                thYour.dataset.date = dateString;
                yourTableHeadRow.appendChild(thYour);

                const thGroup = document.createElement('th');
                thGroup.textContent = formattedDate;
                thGroup.dataset.date = dateString;
                groupTableHeadRow.appendChild(thGroup);
            });

            // --- Generate Table Body (Time Slots) ---
            const times = createRows(start, end);

            if (times.length === 0 || sortedDates.length === 0) {
                const colSpan = Math.max(sortedDates.length + 1, 1); // Span across date columns + time column
                const message = times.length === 0 ? "Error: Invalid time range." : "No dates selected.";
                console.error(message);
                yourTableBody.innerHTML = `<tr><td colspan="${colSpan}">${message}</td></tr>`;
                groupTableBody.innerHTML = `<tr><td colspan="${colSpan}">${message}</td></tr>`;
                updateGroupStatus(); // Update status even if empty
                return;
            }

            times.forEach((time) => {
                const rowYour = document.createElement('tr');
                const rowGroup = document.createElement('tr');

                // Time cell
                const timeCellYour = document.createElement('td');
                timeCellYour.textContent = time;
                const timeCellGroup = timeCellYour.cloneNode(true);
                rowYour.appendChild(timeCellYour);
                rowGroup.appendChild(timeCellGroup);

                // Data cells for each date
                dateHeaders.forEach(headerInfo => {
                    const dateString = headerInfo.full;

                    // Your Time Cell
                    const tdYour = document.createElement('td');
                    tdYour.classList.add(YOUR_TIME_CLASSES.none);
                    tdYour.dataset.time = time;
                    tdYour.dataset.date = dateString; // Use YYYY-MM-DD
                    rowYour.appendChild(tdYour);

                    // Group Time Cell
                    const tdGroup = document.createElement('td');
                    tdGroup.classList.add(GROUP_COLOR_CLASSES[0]);
                    tdGroup.dataset.count = "0";
                    tdGroup.dataset.time = time;
                    tdGroup.dataset.date = dateString; // Use YYYY-MM-DD
                    rowGroup.appendChild(tdGroup);
                });

                yourTableBody.appendChild(rowYour);
                groupTableBody.appendChild(rowGroup);
            });

            setupTableInteraction('#your-table', handleYourCellInteraction);
            setupTableInteraction('#group-table', handleGroupCellInteraction);
            updateGroupStatus();
        }


        function setupTableInteraction(tableSelector, cellHandler) {
            const table = document.querySelector(tableSelector);
            if (!table) return;
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            // --- Mouse Events ---
            tbody.addEventListener('mousedown', (e) => {
                // Check if target is a TD and NOT the first cell (time label)
                if (e.target.tagName === 'TD' && e.target.cellIndex > 0) {
                    isDragging = true;
                    currentDragState = cellHandler(e.target, 'mousedown');
                    e.preventDefault();
                }
            });
            tbody.addEventListener('mouseover', (e) => {
                if (isDragging && e.target.tagName === 'TD' && e.target.cellIndex > 0) {
                    cellHandler(e.target, 'mouseover', currentDragState);
                }
            });
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    currentDragState = null;
                }
            });
            document.addEventListener('mouseleave', () => {
                 if (isDragging) {
                    isDragging = false;
                    currentDragState = null;
                }
            });

            // --- Touch Events ---
            tbody.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'TD' && e.target.cellIndex > 0) {
                    isDragging = true;
                    currentDragState = cellHandler(e.target, 'mousedown');
                    // Don't prevent default immediately for touchstart to allow scrolling
                }
            }, { passive: true });

            tbody.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault(); // Prevent scroll ONLY when dragging cells
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.tagName === 'TD' && element.closest(tableSelector) && element.cellIndex > 0) {
                         cellHandler(element, 'mouseover', currentDragState);
                    }
                }
            }, { passive: false });

            const endTouch = () => {
                if (isDragging) {
                    isDragging = false;
                    currentDragState = null;
                }
            };
            document.addEventListener('touchend', endTouch);
            document.addEventListener('touchcancel', endTouch);
        }

        // Updated: Handle only 'none' and 'available' states
        function handleYourCellInteraction(cell, eventType, dragState) {
            const states = [YOUR_TIME_CLASSES.none, YOUR_TIME_CLASSES.available];
            let currentStateIndex = states.findIndex(cls => cell.classList.contains(cls));
            if (currentStateIndex === -1) currentStateIndex = 0;

            let nextStateClass;

            if (eventType === 'mousedown') {
                const nextStateIndex = (currentStateIndex + 1) % states.length;
                nextStateClass = states[nextStateIndex];
                cell.classList.remove(...Object.values(YOUR_TIME_CLASSES));
                cell.classList.add(nextStateClass);
                return nextStateClass;
            } else if (eventType === 'mouseover' && dragState) {
                if (!cell.classList.contains(dragState)) {
                    cell.classList.remove(...Object.values(YOUR_TIME_CLASSES));
                    cell.classList.add(dragState);
                }
                return dragState;
            }
             return states[currentStateIndex];
        }


        function handleGroupCellInteraction(cell, eventType, dragState) {
             let currentCount = parseInt(cell.dataset.count) || 0;
             let nextCount;

             if (eventType === 'mousedown') {
                 nextCount = (currentCount + 1) % (groupMax + 1);
                 cell.dataset.count = nextCount;
                 cell.classList.remove(...GROUP_COLOR_CLASSES);
                 cell.classList.add(GROUP_COLOR_CLASSES[nextCount]);
                 updateGroupStatus();
                 return nextCount;
             } else if (eventType === 'mouseover' && dragState !== null) {
                 const dragCount = parseInt(dragState);
                 if (currentCount !== dragCount) {
                     cell.dataset.count = dragCount;
                     cell.classList.remove(...GROUP_COLOR_CLASSES);
                     cell.classList.add(GROUP_COLOR_CLASSES[dragCount]);
                     updateGroupStatus();
                 }
                 return dragCount;
             }
             return currentCount;
        }


        function updateGroupStatus() {
            let fullyAvailableCount = 0;
            // Check if groupTableBody has child nodes before querying
            if (!groupTableBody || !groupTableBody.hasChildNodes()) {
                 groupStatusSpan.textContent = `0/0 Fully Available`;
                 return;
            }
            // Query only data cells (skip time header cell if it were part of query)
            const groupCells = groupTableBody.querySelectorAll('td[data-count]');
            const totalCells = groupCells.length;

            groupCells.forEach(cell => {
                if (parseInt(cell.dataset.count) === groupMax) {
                    fullyAvailableCount++;
                }
            });
            groupStatusSpan.textContent = `${fullyAvailableCount}/${totalCells || 0} Fully Available`;
        }


        function resetAll() {
             // Select only data cells (index > 0) in your table body
             yourTableBody.querySelectorAll('td:not(:first-child)').forEach(cell => {
                 cell.classList.remove(...Object.values(YOUR_TIME_CLASSES));
                 cell.classList.add(YOUR_TIME_CLASSES.none);
             });
             // Select only data cells (index > 0) in group table body
             groupTableBody.querySelectorAll('td:not(:first-child)').forEach(cell => {
                 cell.dataset.count = 0;
                 cell.classList.remove(...GROUP_COLOR_CLASSES);
                 cell.classList.add(GROUP_COLOR_CLASSES[0]);
             });
             updateGroupStatus();
             console.log("Tables reset.");
        }

        function saveSchedule() {
            let timetableName = "Untitled Schedule";
            let startTime = "09:00";
            let endTime = "17:00"; // Represents the *start* of the last slot
            let savedDates = [];
            const savedData = localStorage.getItem('schedule_data');
             if (savedData) {
                try {
                    const scheduleData = JSON.parse(savedData);
                    timetableName = scheduleData.timetableName || timetableName;
                    startTime = scheduleData.startTime || startTime;
                    savedDates = scheduleData.selectedDates || [];
                    // Calculate end time label correctly (if end hour is 18, last label is 17:00)
                    const endHour = parseInt(scheduleData.endTime?.split(':')[0]);
                    if (!isNaN(endHour) && endHour > 0) {
                        // The endTime in the saved data represents the hour *after* the last slot.
                        // The last time label should be one hour before that.
                        endTime = (endHour - 1).toString().padStart(2, '0') + ':00';
                    } else {
                         endTime = scheduleData.endTime || endTime; // Fallback or keep default
                    }
                } catch (e) {
                    console.error("Error parsing schedule data for saving:", e);
                }
            }

            const participants = []; // Still no participant list UI

            // Get date headers (YYYY-MM-DD) from the table header
            const dateHeaderElements = yourTableHeadRow.querySelectorAll('th[data-date]');
            const dateColumns = Array.from(dateHeaderElements).map(th => th.dataset.date);

            // Function to extract data, now aware of dynamic columns
            const getTableData = (tableBody, dataExtractor) => {
                return Array.from(tableBody.querySelectorAll('tr')).map(row => {
                    // Select all data cells (skip the first time label cell)
                    const cells = row.querySelectorAll('td:not(:first-child)');
                    return Array.from(cells).map(dataExtractor);
                });
            };

            const yourData = getTableData(yourTableBody, cell => {
                 if (cell.classList.contains(YOUR_TIME_CLASSES.available)) return 'available';
                 return 'none';
            });

            const groupData = getTableData(groupTableBody, cell => parseInt(cell.dataset.count) || 0);

            const timeLabels = Array.from(yourTableBody.querySelectorAll('tr')).map(row => row.cells[0]?.textContent || '');

            const result = {
                name: timetableName,
                participants: participants,
                timeLabels: timeLabels.filter(label => label),
                dateColumns: dateColumns, // Add the date columns used
                yourAvailability: yourData, // 2D array [time][date]
                groupAvailability: groupData, // 2D array [time][date]
                startTime: startTime, // Actual start time from settings/default
                endTime: endTime     // Actual end time label from settings/default
            };

            console.log("Saved Data:", JSON.stringify(result, null, 2));
            alert(`Schedule "${timetableName}" saved! Check the browser console for details.`);

            // Potential future backend saving:
            // fetch('/api/save-schedule', { ... });
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            populateTables(); // Populate based on localStorage or defaults
        });

    </script>
</body>
</html>
